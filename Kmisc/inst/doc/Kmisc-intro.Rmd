<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{Introduction to Kmisc}
\usepackage[utf8]{inputenc}
-->

<link rel="stylesheet" href="markdown.css">

Quick Introduction to Kmisc
=====

Kmisc introduces a bunch of utility functions to make the R coding experience
a bit easier. Some of the most useful functions in the package are shown here.

```{r, tidy=FALSE}
set.seed(123)
suppressPackageStartupMessages( library(Kmisc) )
dat <- data.frame( x=letters[1:4], y=1:4, z=LETTERS[1:4] )

```

`without`: This function is used to remove columns from a `list` / `data.frame`.

```{r, tidy=FALSE}
## let's remove columns 'x' and 'z' from dat.
dat[ !(names(dat) %in% c('x', 'z')) ]

## I always find that syntax awkward. Let's use Kmisc::without instead.
without( dat, x, z )

## what if there is a variable 'x' in the global environment?
x <- "a"
without( dat, x, z )
## finally, we can also index by $ (note: NOT done by partial matching):
without( dat, dat$x, dat$z )
## this could be handy for vectors with very long names, if using an IDE with
## auto-complete
```

`extract`: Extract vectors from a data.frame or list. Although there is already
a good subsetting syntax for lists and vectors, I wanted a complementary
function for `without`.

```{r tidy=FALSE}
extract( dat, x, y)
```

`without.re, extract.re`: Extract variables whose names don't match / do match
a regular expression pattern.
```{r tidy=FALSE}
extract.re( dat, "[xy]")
without.re( dat, "[xy]")
```

`swap`: Replace elements in a vector.

```{r tidy=FALSE}
tDat <- dat ## make a temporary copy of dat

## Replace some elements in tDat$y
tDat$y <- swap( tDat$y, from=c(2, 4), to=c(20, 40) )
cbind( dat$y, tDat$y )
```

`factor_to_char`, `char_to_factor`: A set of functions that recurse through
a list / data.frame and set all elements that are characters to factors,
and vice versa.

```{r tidy=FALSE}
bDat <- data.frame( x=rnorm(10), y=sample(letters,10), z=sample(letters,10) )
str( bDat )
str( factor_to_char(bDat) )
```

`dapply`: The `data.frame` version of the `l/sapply` series of functions.

Why have this function when `sapply` still does much the same? I always get
frustrated with the fact that either an `array` or a `list` is returned
by sapply, but never a `data.frame`.

```{r, tidy=FALSE}

dat <- data.frame( x = rnorm(100), y = rnorm(100), z = rnorm(100) )
dapply( dat, summary )
```

`kMerge`: Left joins, aka. `merge( all.x=TRUE, ... )` without any mangling 
of the order.

```{r, tidy=FALSE}
dat1 <- data.frame( id=5:1, x=c("a","a","b","b","b"), y=rnorm(5) )
dat2 <- data.frame( id=c(1, 2, 4), z=rnorm(3) )

## default merge changes id order
merge( dat1, dat2, by="id", all.x=TRUE )
## even the sort parameter can't save you
merge( dat1, dat2, by="id", all.x=TRUE, sort=TRUE )
# kMerge keeps it as is
kMerge( dat1, dat2, by="id" )
```

`in_interval`: A fast C implementation for determing which elements of a 
vector `x` lie within an interval `[lo, hi)`.

```{r tidy=FALSE}
x <- runif(10); lo <- 0.5; hi <- 1
print( data.frame( x=x, inner=in_interval(x, lo, hi) ) )
```

`stack_list`: Use this to stack data.frames in a list. This can be useful if
e.g. you've run some kind of bootstrap procedure and have all your results
stored in as a list of data.frames -- even `do.call( rbind, dfs )` can be slow.
The difference is even more prominent when used on very large lists.

```{r tidy=FALSE}
dfs <- replicate(1E3, 
                 data.frame(x=rnorm(10), y=sample(letters,10), z=sample(LETTERS,10)),
                 simplify=FALSE
                 )
str( stack_list(dfs) )
system.time( stack_list(dfs) )
system.time( do.call(rbind, dfs) )
```

Fast String Operations
-----

For whatever reason, R is missing some nice builtin 'string' functions. I've
introduced a few functions, implemented in C for speed, for two common
string operations.

`str_rev`: Reverses a character vector; ie, a vector of strings.
`str_rev2` is there if you need to reverse a potentially unicode string.

```{r tidy=FALSE}
str_rev( c("ABC", "DEF", NA, paste(LETTERS, collapse="") ) )
str_rev2( c("はひふへほ", "abcdef") )
```

`str_slice`: Slices a vector of strings at consecutive indices `n`.
`str_slice2` exists for potentially unicode strings.
```{r tidy=FALSE}
str_slice( c("ABCDEF", "GHIJKL", "MNOP", "QR"), 2 )
str_slice2( "ハッピー", 2 )
```

`str_sort`: sort a string.
```{r, tidy=FALSE}
str_sort("asnoighewgypfuiweb")
```

The cool R Markdown / HTML Stuff
-----

The real point of releasing this package is due to the HTML helper functions
I've made. I've found them especially useful in laying out R Markdown documents,
and also controlling more finely CSS styling and such.

`makeHTMLTable`: Converts a `data.frame` or `matrix` into an HTML table.
Best seen with an example. Note that we require `results='asis'` in the chunk
options.

```{r results='asis'}
dat <- data.frame( apple=c('a', 'b', 'c'), banana=c(1, 2, 3) )
makeHTMLTable( dat, use.col.names=TRUE )
```

`kTable`: Generated 1D and 2D (contingency) tables, which are then typically
passed through `makeHTMLtable` for 1D tables, or `pxt` for 2D tables.

```{r results='asis', tidy=FALSE}
x <- factor( rbinom(100, 2, 0.2) )
y <- factor( rbinom(100, 3, 0.3) )

p1t( kTable( x, top.left.cell="foo" ) )
pxt( kTable(x, y, 
            top.left.cell="foo", 
            top.label="bar", 
            left.label="baz" 
            ) )

```

`kTable` with `google=TRUE`: Generate a 1D table output with the `googleVis`
package.

```{r results='asis', tidy=FALSE}
suppressPackageStartupMessages( library(googleVis) )
tmp <- gvisTable( kTable(x, google=TRUE) )
cat( tmp$html$chart )
```

`hImg, hSvg`: These utility functions do the work of simultaneously writing a
plot to file, and then producing the HTML code needed to embed that plot in
the page. Once again, we require `results='asis'` in the chunk options. I
also show off the nice little `gradient` function.

```{r results='asis', tidy=FALSE}
x <- rnorm(100); y <- x + runif(100)
## note that the default resolution is high for PNGs
hImg( file="test.png", width=400, height=300, dpi=300,
      xyplot( y ~ x, col=gradient(x+y) )
      )
hSvg( file="test.svg", width=400, height=300,
      xyplot( y ~ x, col=gradient(x+y) )
      )
```

`kCoef, kAnova`: These are functions that produce 'nicer' coefficient output
from a model fit, especially when factors are used. However, they don't work
quite right for models with interaction effects yet.

```{r tidy=FALSE}
x <- rnorm(100); y <- x + runif(100)
z <- factor( rep(c('a','b','c','d'), each=25) )

myFit <- lm( y ~ x + z )

## the vanilla way
coef( summary( myFit ) )

## nicer parsing of variable names
kCoef( myFit )
```

`html`: Custom HTML in an R Markdown document.

```{r results='asis', tidy=FALSE}
html(
     table( class="my-favourite-table",
            tr(
              td("Apples"),
              td("Bananas")
              ),
            tr(
              td("20"),
              td("30")
              )
            )
     )
```